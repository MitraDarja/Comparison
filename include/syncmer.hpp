// -----------------------------------------------------------------------------------------------------
// Copyright (c) 2006-2021, Knut Reinert & Freie Universität Berlin
// Copyright (c) 2016-2021, Knut Reinert & MPI für molekulare Genetik
// This file may be used, modified and/or redistributed under the terms of the 3-clause BSD-License
// shipped with this file and also available at: https://github.com/seqan/seqan3/blob/master/LICENSE.md
// -----------------------------------------------------------------------------------------------------

/*!\file
 * \author Hossein Eizadi Moghadam <hosseinem AT fu-berlin.de> & Mitra Darvish <mitra darvish AT fu-berlin.de>
 * \brief Provides syncmer.
 */

#pragma once

#include <seqan3/std/algorithm>
#include <deque>

#include <seqan3/alphabet/nucleotide/dna4.hpp>
#include <seqan3/core/detail/empty_type.hpp>
#include <seqan3/core/range/detail/adaptor_from_functor.hpp>
#include <seqan3/core/range/type_traits.hpp>
#include <seqan3/utility/range/concept.hpp>
#include <seqan3/utility/type_traits/lazy_conditional.hpp>

namespace seqan3::detail
{
// ---------------------------------------------------------------------------------------------------------------------
// syncmer_view class
// ---------------------------------------------------------------------------------------------------------------------

/*!\brief The type returned by syncmer.
 * \tparam urng1_t The type of the first underlying range, must model std::ranges::forward_range, the reference type
 *                 must model std::totally_ordered. The typical use case is that the reference type is the result of
 *                 seqan3::kmer_hash.
 * \tparam urng2_t The type of the second underlying range, must model std::ranges::forward_range, the reference
 *                 type must model std::totally_ordered. The typical use case is that the reference type is the
 *                 result of seqan3::kmer_hash.
 *
 * \implements std::ranges::view
 * \ingroup search_views
 *
 * \note Most members of this class are generated by std::ranges::view_interface which is not yet documented here.

 */
template <std::ranges::view urng1_t,
          std::ranges::view urng2_t,
          std::ranges::view urng3_t = std::ranges::empty_view<seqan3::detail::empty_type>,
          std::ranges::view urng4_t = std::ranges::empty_view<seqan3::detail::empty_type>>
class syncmer_view : public std::ranges::view_interface<syncmer_view<urng1_t, urng2_t>>
{
private:
    static_assert(std::ranges::forward_range<urng1_t>, "The syncmer_view only works on forward_ranges.");
    static_assert(std::ranges::forward_range<urng2_t>, "The syncmer_view only works on forward_ranges.");
    static_assert(std::totally_ordered<std::ranges::range_reference_t<urng1_t>>,
                  "The reference type of the first underlying range must model std::totally_ordered.");
    static_assert(std::totally_ordered<std::ranges::range_reference_t<urng2_t>>,
                  "The reference type of the second underlying range must model std::totally_ordered.");

    //!\brief Whether the given ranges are const_iterable.
    static constexpr bool const_iterable = seqan3::const_iterable_range<urng1_t>;
    static constexpr bool const_iterable2 = seqan3::const_iterable_range<urng2_t>;

    using default_urng_t = std::ranges::empty_view<seqan3::detail::empty_type>;
    static constexpr bool second_range_is_given = !std::same_as<urng3_t, default_urng_t>;

    //!\brief The first underlying range.
    urng1_t urange1{};
    //!\brief The second underlying range.
    urng2_t urange2{};
    //!\brief The third underlying range.
    urng3_t urange3{};
    //!\brief The fourth underlying range.
    urng4_t urange4{};
    //!\brief The number of elements in one window (should be window size - subwindow size + 1).
    size_t window_size{};
    //!\brief The offset for the position of the smallest sub-window.
    size_t t{};

    std::vector<int> positions{};

    template <bool const_range>
    class basic_iterator;

    //!\brief The sentinel type of the syncmer_view.
    using sentinel = std::default_sentinel_t;

public:
    /*!\name Constructors, destructor andt assignment
     * \{
     */
     /// \cond Workaround_Doxygen
    syncmer_view() requires  std::default_initializable<urng1_t> && std::default_initializable<urng2_t> = default; //!< Defaulted.
    /// \endcond
    syncmer_view(syncmer_view const & rhs) = default; //!< Defaulted.
    syncmer_view(syncmer_view && rhs) = default; //!< Defaulted.
    syncmer_view & operator=(syncmer_view const & rhs) = default; //!< Defaulted.
    syncmer_view & operator=(syncmer_view && rhs) = default; //!< Defaulted.
    ~syncmer_view() = default; //!< Defaulted.

    /*!\brief Construct from a view and a given number of values in one window.
    * \param[in] urange1     The first input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] urange2     The second input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] window_size The number of elements in one window (should be window size - subwindow size + 1).
    * \param[in] positions   The positions that the smaller elements must be in to be a syncmer.
    */
    syncmer_view(urng1_t urange1, urng2_t urange2, size_t const window_size, std::vector<int> const positions) :
        urange1{std::move(urange1)},
        urange2{std::move(urange2)},
        urange3{default_urng_t{}},
        urange4{default_urng_t{}},
        window_size{window_size},
        positions{positions}
    {}

    /*!\brief Construct from a non-view that can be view-wrapped and a given number of values in one window.
    * \tparam other_urng1_t  The type of another urange. Must model std::ranges::viewable_range and be
    *                        constructible from urng1_t.
    * \tparam other_urng2_t  The type of another urange. Must model std::ranges::viewable_range and be
    *                        constructible from urng2_t.
    * \param[in] urange1     The first input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] urange2     The second input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] window_size The number of elements in one window (should be window size - subwindow size + 1).
    * \param[in] positions   The positions that the smaller elements must be in to be a syncmer.
    */
    template <typename other_urng1_t, typename other_urng2_t>
    //!\cond
        requires (std::ranges::viewable_range<other_urng1_t> &&
                  std::constructible_from<urng1_t, ranges::ref_view<std::remove_reference_t<other_urng1_t>>> &&
                  std::ranges::viewable_range<other_urng2_t> &&
                            std::constructible_from<urng2_t, ranges::ref_view<std::remove_reference_t<other_urng2_t>>>)
    //!\endcond
    syncmer_view(other_urng1_t && urange1, other_urng2_t && urange2, size_t const window_size, std::vector<int> const positions) :
        urange1{std::views::all(std::forward<other_urng1_t>(urange1))},
        urange2{std::views::all(std::forward<other_urng2_t>(urange2))},
        urange3{default_urng_t{}},
        urange4{default_urng_t{}},
        window_size{window_size},
        positions{positions}
    {}

    /*!\brief Construct from a view and a given number of values in one window.
    * \param[in] urange1     The first input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] urange2     The second input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] urange3     The third input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] urange4     The fourth input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] window_size The number of elements in one window (should be window size - subwindow size + 1).
    * \param[in] positions   The positions that the smaller elements must be in to be a syncmer.
    */
    syncmer_view(urng1_t urange1, urng2_t urange2, urng3_t urange3, urng4_t urange4, size_t const window_size, std::vector<int> const positions) :
        urange1{std::move(urange1)},
        urange2{std::move(urange2)},
        urange3{std::move(urange3)},
        urange4{std::move(urange4)},
        window_size{window_size},
        positions{positions}
    {}

    /*!\brief Construct from a non-view that can be view-wrapped and a given number of values in one window.
    * \tparam other_urng1_t  The type of another urange. Must model std::ranges::viewable_range and be
    *                        constructible from urng1_t.
    * \tparam other_urng2_t  The type of another urange. Must model std::ranges::viewable_range and be
    *                        constructible from urng2_t.
    * \tparam other_urng3_t  The type of another urange. Must model std::ranges::viewable_range and be
    *                        constructible from urng3_t.
    * \tparam other_urng4_t  The type of another urange. Must model std::ranges::viewable_range and be
    *                        constructible from urng4_t.
    * \param[in] urange1     The first input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] urange2     The second input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] urange3     The third input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] urange4     The fourth input range to process. Must model std::ranges::viewable_range and
    *                        std::ranges::forward_range.
    * \param[in] window_size The number of elements in one window (should be window size - subwindow size + 1).
    * \param[in] positions   The positions that the smaller elements must be in to be a syncmer.
    */
    template <typename other_urng1_t, typename other_urng2_t, typename other_urng3_t, typename other_urng4_t>
    //!\cond
        requires (std::ranges::viewable_range<other_urng1_t> &&
                  std::constructible_from<urng1_t, ranges::ref_view<std::remove_reference_t<other_urng1_t>>> &&
                  std::ranges::viewable_range<other_urng2_t> &&
                            std::constructible_from<urng2_t, ranges::ref_view<std::remove_reference_t<other_urng2_t>>> &&
                 std::ranges::viewable_range<other_urng3_t> &&
                          std::constructible_from<urng3_t, ranges::ref_view<std::remove_reference_t<other_urng3_t>>> &&
                          std::ranges::viewable_range<other_urng4_t> &&
                                    std::constructible_from<urng4_t, ranges::ref_view<std::remove_reference_t<other_urng4_t>>>)

    //!\endcond
    syncmer_view(other_urng1_t && urange1, other_urng2_t && urange2, other_urng3_t && urange3, other_urng4_t && urange4, size_t const window_size, std::vector<int> const positions) :
        urange1{std::views::all(std::forward<other_urng1_t>(urange1))},
        urange2{std::views::all(std::forward<other_urng2_t>(urange2))},
        urange3{std::move(urange3)},
        urange4{std::move(urange4)},
        window_size{window_size},
        positions{positions}
    {}
    /*!\name Iterators
     * \{
     */
    /*!\brief Returns an iterator to the first element of the range.
     * \returns Iterator to the first element.
     *
     * \details
     *
     * ### Complexity
     *
     * Constant.
     *
     * ### Exceptions
     *
     * Strong exception guarantee.
     */
    basic_iterator<false> begin()
    {
        return {std::ranges::begin(urange1),
                std::ranges::begin(urange2),
                std::ranges::end(urange1),
                std::ranges::begin(urange3),
                std::ranges::begin(urange4),
                window_size,
                positions};
    }

    //!\copydoc begin()
    basic_iterator<true> begin() const
    //!\cond
        requires const_iterable && const_iterable2
    //!\endcond
    {
        return {std::ranges::cbegin(urange1),
                std::ranges::cbegin(urange2),
                std::ranges::cend(urange1),
                std::ranges::cbegin(urange3),
                std::ranges::cbegin(urange4),
                window_size,
                positions};
    }

    /*!\brief Returns an iterator to the element following the last element of the range.
     * \returns Iterator to the end.
     *
     * \details
     *
     * This element acts as a placeholder; attempting to dereference it results in undefined behaviour.
     *
     * ### Complexity
     *
     * Constant.
     *
     * ### Exceptions
     *
     * No-throw guarantee.
     */
    sentinel end() const
    {
        return {};
    }
    //!\}
};

//!\brief Iterator for calculating syncmers.
template <std::ranges::view urng1_t, std::ranges::view urng2_t, std::ranges::view urng3_t, std::ranges::view urng4_t>
template <bool const_range>
class syncmer_view<urng1_t, urng2_t, urng3_t, urng4_t>::basic_iterator
{
private:
    //!\brief The sentinel type of the first underlying range.
    using urng1_sentinel_t = maybe_const_sentinel_t<const_range, urng1_t>;
    //!\brief The iterator type of the first underlying range.
    using urng1_iterator_t = maybe_const_iterator_t<const_range, urng1_t>;
    //!\brief The iterator type of the second underlying range.
    using urng2_iterator_t = maybe_const_iterator_t<const_range, urng2_t>;
    //!\brief The iterator type of the third underlying range.
    using urng3_iterator_t = maybe_const_iterator_t<const_range, urng3_t>;
    //!\brief The iterator type of the fourth underlying range.
    using urng4_iterator_t = maybe_const_iterator_t<const_range, urng4_t>;

    template <bool>
    friend class basic_iterator;

public:
    /*!\name Associated types
     * \{
     */
    //!\brief Type for distances between iterators.
    using difference_type = std::ranges::range_difference_t<urng1_t>;
    //!\brief Value type of this iterator.
    using value_type = std::ranges::range_value_t<urng2_t>;
    //!\brief The pointer type.
    using pointer = void;
    //!\brief Reference to `value_type`.
    using reference = value_type;
    //!\brief Tag this class as a forward iterator.
    using iterator_category = std::forward_iterator_tag;
    //!\brief Tag this class as a forward iterator.
    using iterator_concept = iterator_category;
    //!\}

    /*!\name Constructors, destructor and assignment
     * \{
     */
    basic_iterator() = default; //!< Defaulted.
    basic_iterator(basic_iterator const &) = default; //!< Defaulted.
    basic_iterator(basic_iterator &&) = default; //!< Defaulted.
    basic_iterator & operator=(basic_iterator const &) = default; //!< Defaulted.
    basic_iterator & operator=(basic_iterator &&) = default; //!< Defaulted.
    ~basic_iterator() = default; //!< Defaulted.

    //!\brief Allow iterator on a const range to be constructible from an iterator over a non-const range.
    basic_iterator(basic_iterator<!const_range> const & it)
    //!\cond
        requires const_range
    //!\endcond
        : syncmer_value{std::move(it.syncmer_value)},
          urng1_iterator{std::move(it.urng1_iterator)},
          urng2_iterator{std::move(it.urng2_iterator)},
          urng1_sentinel{std::move(it.urng1_sentinel)},
          urng3_iterator{std::move(it.urng3_iterator)},
          urng4_iterator{std::move(it.urng4_iterator)},
          w_size{std::move(it.w_size)}
    {}

    /*!\brief Construct from begin and end iterators of a given range over std::totally_ordered values, and the number
              of values per window.
    * \param[in] urng1_iterator Iterator pointing to the first position of the first std::totally_ordered range.
    * \param[in] urng2_iterator Iterator pointing to the first position of the second std::totally_ordered range.
    * \param[in] urng1_sentinel Iterator pointing to the last position of the first std::totally_ordered range.
    * \param[in] window_size The number of elements in one window (should be window size - subwindow size + 1).
    * \param[in] positions   The position that determines if an element is a syncmer.
    *
    * \details
    *
    * Looks at the number of values per window in two ranges, if the smallest subwindow in a window is at its start
    * or end, it returns the window as a syncmer and shifts then by one to repeat this action.
    */
    basic_iterator(urng1_iterator_t urng1_iterator,
                   urng2_iterator_t urng2_iterator,
                   urng1_sentinel_t urng1_sentinel,
                   urng3_iterator_t urng3_iterator,
                   urng4_iterator_t urng4_iterator,
                   size_t window_size,
                   std::vector<int> positions) :
        urng1_iterator{std::move(urng1_iterator)},
        urng2_iterator{std::move(urng2_iterator)},
        urng1_sentinel{std::move(urng1_sentinel)},
        urng3_iterator{std::move(urng3_iterator)},
        urng4_iterator{std::move(urng4_iterator)},
        positions{positions}
    {
        size_t size = std::ranges::distance(urng1_iterator, urng1_sentinel);

        if (window_size > size)
            throw std::invalid_argument{"The given sequence is too short to satisfy the given window_size.\n"
                                        "Please choose a smaller window_size."};

        window_first(window_size);
    }
    //!\}

    //!\anchor basic_iterator_comparison_syncmer
    //!\name Comparison operators
    //!\{

    //!\brief Compare to another basic_iterator.
    friend bool operator==(basic_iterator const & lhs, basic_iterator const & rhs)
    {
        return (lhs.urng1_iterator == rhs.urng1_iterator) &&
               (rhs.urng2_iterator == rhs.urng2_iterator) &&
               (lhs.urng3_iterator == rhs.urng3_iterator) &&
               (rhs.urng4_iterator == rhs.urng4_iterator) &&
               (lhs.w_size == rhs.w_size);
    }

    //!\brief Compare to another basic_iterator.
    friend bool operator!=(basic_iterator const & lhs, basic_iterator const & rhs)
    {
        return !(lhs == rhs);
    }

    //!\brief Compare to the sentinel of the syncmer_view.
    friend bool operator==(basic_iterator const & lhs, sentinel const &)
    {
        return lhs.urng1_iterator == lhs.urng1_sentinel;
    }

    //!\brief Compare to the sentinel of the syncmer_view.
    friend bool operator==(sentinel const & lhs, basic_iterator const & rhs)
    {
        return rhs == lhs;
    }

    //!\brief Compare to the sentinel of the syncmer_view.
    friend bool operator!=(sentinel const & lhs, basic_iterator const & rhs)
    {
        return !(lhs == rhs);
    }

    //!\brief Compare to the sentinel of the syncmer_view.
    friend bool operator!=(basic_iterator const & lhs, sentinel const & rhs)
    {
        return !(lhs == rhs);
    }
    //!\}

    //!\brief Pre-increment.
    basic_iterator & operator++() noexcept
    {
        next_unique_syncmer();
        return *this;
    }

    //!\brief Post-increment.
    basic_iterator operator++(int) noexcept
    {
        basic_iterator tmp{*this};
        next_unique_syncmer();
        return tmp;
    }

    //!\brief Return the syncmer.
    value_type operator*() const noexcept
    {
        return syncmer_value;
    }

private:
    //!\brief The syncmer value.
    value_type syncmer_value{};

    //!\brief The offset relative to the beginning of the window where the syncmer value is found.
    int syncmer_position_offset{};

    //!\brief The offset relative to the beginning of the window where the syncmer value is found for the third and fourth range.
    int syncmer_position_offset2{};

    //!\brief Iterator to the rightmost value of one kmer.
    urng1_iterator_t urng1_iterator{};

    //!\brief Iterator to the rightmost value of one kmer in the second range.
    urng2_iterator_t urng2_iterator{};

    //!brief Iterator to last element in range.
    urng1_sentinel_t urng1_sentinel{};

    //!\brief Iterator to the rightmost value of one kmer of the third range.
    urng3_iterator_t urng3_iterator{};

    //!\brief Iterator to the rightmost value of one kmer in the fourth range.
    urng4_iterator_t urng4_iterator{};

    //!\brief Stored values per window. It is necessary to store them, because a shift can remove the current syncmer.
    std::deque<value_type> window_values{};

    //!\brief Stored values per window for third and fourth range. It is necessary to store them, because a shift can remove the current syncmer.
    std::deque<value_type> window_values2{};

    //!brief The number of elements in one window.
    size_t w_size{};

    //!brief The position that determines if an element is a syncmer.
    std::vector<int> positions{};

    //!\brief Increments iterator by 1.
    void next_unique_syncmer()
    {
        while (!next_syncmer()) {}
    }

    //!\brief Advances both windows to the next position.
    void advance_window()
    {
        ++urng1_iterator;
        ++urng2_iterator;

        if constexpr (second_range_is_given)
        {
            ++urng3_iterator;
            ++urng4_iterator;
        }
    }

    //!\brief Calculates syncmers for the first window.
    void window_first(const size_t window_size)
    {
        w_size = window_size;
        if (window_size == 0u)
            return;

        for (int i = 0u; i < w_size - 1 ; ++i)
        {
            window_values.push_back(*urng1_iterator);
            ++urng1_iterator;

            if constexpr (second_range_is_given)
            {
                window_values2.push_front(*urng3_iterator);
                ++urng3_iterator;
            }
        }
        window_values.push_back(*urng1_iterator);
        if constexpr (second_range_is_given)
            window_values2.push_front(*urng3_iterator);

	auto smallest_s_it = std::ranges::min_element(window_values, std::less<value_type>{});
        syncmer_position_offset = std::distance(std::begin(window_values), smallest_s_it);

        if constexpr (second_range_is_given)
        {
	    smallest_s_it = std::ranges::min_element(window_values2, std::less<value_type>{});
            syncmer_position_offset2 = std::distance(std::begin(window_values2), smallest_s_it);

            if (*urng2_iterator < *urng4_iterator)
            {
                if (std::find(positions.begin(), positions.end(), syncmer_position_offset) != positions.end())
                    syncmer_value = *urng2_iterator;
                else
                    next_unique_syncmer();
            }
            else
            {
                if (std::find(positions.begin(), positions.end(), syncmer_position_offset2) != positions.end())
                    syncmer_value = *urng4_iterator;
                else
                    next_unique_syncmer();
            }
        }
        else
        {
            if (std::find(positions.begin(), positions.end(), syncmer_position_offset) != positions.end())
                syncmer_value = *urng2_iterator;
            else
                next_unique_syncmer();
        }
    }

    /*!\brief Calculates the next syncmer value.
     * \returns True, if new syncmer is found or end is reached. Otherwise returns false.
     * \details
     * For the following windows, we remove the first window value (is now not in window_values) and add the new
     * value that results from the window shifting.
     */
    bool next_syncmer()
    {
        advance_window();

        if (urng1_iterator == urng1_sentinel)
            return true;

        value_type const new_value = *urng1_iterator;
        window_values.pop_front();
        window_values.push_back(new_value);
        syncmer_position_offset--;

        if (syncmer_position_offset < 0)
        {
            auto smallest_s_it = std::ranges::min_element(window_values, std::less<value_type>{});
            syncmer_position_offset = std::distance(std::begin(window_values), smallest_s_it);
        }
        else if (new_value < *(window_values.begin()+(syncmer_position_offset)))
        {
            syncmer_position_offset = w_size - 1;
        }

        if constexpr (second_range_is_given)
        {
            value_type const new_value2 = *urng3_iterator;
            window_values2.pop_back();
            window_values2.push_front(new_value2);
            syncmer_position_offset2++;

            if (syncmer_position_offset2 >= window_values2.size())
            {
                auto smallest_s_it = std::ranges::min_element(window_values2, std::less<value_type>{});
                syncmer_position_offset2 = std::distance(std::begin(window_values2), smallest_s_it);
            }
            else if (new_value2 <= *(window_values2.begin()+(syncmer_position_offset2)))
            {
                syncmer_position_offset2 = 0;
            }

            if (*urng2_iterator > *urng4_iterator)
            {
                if (std::find(positions.begin(), positions.end(), syncmer_position_offset2) != positions.end())
                {
                    syncmer_value = *urng4_iterator;
                    return true;
                }
                else
                {
                    return false;
                }
            }
	    else
	    {
		if (std::find(positions.begin(), positions.end(), syncmer_position_offset) != positions.end())
	        {
        	    syncmer_value = *urng2_iterator;
            	    return true;
        	}
        	else
        	{
            	    return false;
        	}

	    }
        }

        if (std::find(positions.begin(), positions.end(), syncmer_position_offset) != positions.end())
        {
            syncmer_value = *urng2_iterator;
            return true;
        }
        else
        {
            return false;
        }
    }
};



//!\brief A deduction guide for the view class template.
template <std::ranges::viewable_range rng1_t, std::ranges::viewable_range rng2_t>
syncmer_view(rng1_t &&, rng2_t &&, size_t const window_size, std::vector<int> const pos) -> syncmer_view<std::views::all_t<rng1_t>, std::views::all_t<rng2_t>>;

template <std::ranges::viewable_range rng1_t, std::ranges::viewable_range rng2_t, std::ranges::viewable_range rng3_t, std::ranges::viewable_range rng4_t>
syncmer_view(rng1_t &&, rng2_t &&, rng3_t &&, rng4_t &&, size_t const window_size, std::vector<int> const pos) -> syncmer_view<std::views::all_t<rng1_t>, std::views::all_t<rng2_t>, std::views::all_t<rng3_t>, std::views::all_t<rng4_t>>;

// ---------------------------------------------------------------------------------------------------------------------
// syncmer_fn (adaptor definition)
// ---------------------------------------------------------------------------------------------------------------------

//![adaptor_def]
//!\brief syncmer's range adaptor object type (non-closure).
//!\ingroup search_views
struct syncmer_fn
{
    /*!\brief Call the view's constructor with three arguments: the two underlying views and an integer indicating
     *        how many values one window contains.
     * \tparam urng1_t        The type of the first input range to process. Must model std::ranges::viewable_range.
     * \tparam urng2_t        The type of the second input range to process. Must model std::ranges::viewable_range.
     * \param[in] urange1     The input range to process. Must model std::ranges::viewable_range and
     *                        std::ranges::forward_range.
     * \param[in] urange2     The second input range to process. Must model std::ranges::viewable_range and
     *                        std::ranges::forward_range.
     * \param[in] window_size The number of elements in one window (should be window size - subwindow size + 1).
     * \param[in] pos 	      The position that determines if an element is a syncmer.
     * \returns  A range of converted values.
     */
    template <std::ranges::range urng1_t, std::ranges::range urng2_t>
    constexpr auto operator()(urng1_t && urange1, urng2_t && urange2, size_t const window_size, std::vector<int> const pos) const
    {
        static_assert(std::ranges::viewable_range<urng1_t>,
                      "The range parameter to views::syncmer cannot be a temporary of a non-view range.");
        static_assert(std::ranges::forward_range<urng1_t>,
                      "The range parameter to views::syncmer must model std::ranges::forward_range.");

        if (window_size < 2)
            throw std::invalid_argument{"The chosen window_size is not valid."
                                        "Please choose a window_size greater than 1."};

        return syncmer_view{urange1, urange2, window_size, pos};
    }

    /*!\brief Call the view's constructor with three arguments: the two underlying views and an integer indicating
     *        how many values one window contains.
     * \tparam urng1_t        The type of the first input range to process. Must model std::ranges::viewable_range.
     * \tparam urng2_t        The type of the second input range to process. Must model std::ranges::viewable_range.
     * \tparam urng3_t        The type of the third input range to process. Must model std::ranges::viewable_range.
     * \tparam urng4_t        The type of the fourth input range to process. Must model std::ranges::viewable_range.
     * \param[in] urange1     The input range to process. Must model std::ranges::viewable_range and
     *                        std::ranges::forward_range.
     * \param[in] urange2     The second input range to process. Must model std::ranges::viewable_range and
     *                        std::ranges::forward_range.
     * \param[in] urange3     The third input range to process. Must model std::ranges::viewable_range and
     *                        std::ranges::forward_range.
     * \param[in] urange4     The fourth input range to process. Must model std::ranges::viewable_range and
     *                        std::ranges::forward_range.
     * \param[in] window_size The number of elements in one window (should be window size - subwindow size + 1).
     * \param[in] pos	      The position that determines if an element is a syncmer.

     * \returns  A range of converted values.
     */
    template <std::ranges::range urng1_t, std::ranges::range urng2_t, std::ranges::range urng3_t, std::ranges::range urng4_t>
    constexpr auto operator()(urng1_t && urange1, urng2_t && urange2, urng3_t && urange3, urng4_t && urange4, size_t const window_size, std::vector<int> const pos) const
    {
        static_assert(std::ranges::viewable_range<urng1_t>,
                      "The range parameter to views::syncmer cannot be a temporary of a non-view range.");
        static_assert(std::ranges::forward_range<urng1_t>,
                      "The range parameter to views::syncmer must model std::ranges::forward_range.");

        if (window_size < 2)
            throw std::invalid_argument{"The chosen window_size is not valid."
                                        "Please choose a window_size greater than 1."};

        return syncmer_view{urange1, urange2, urange3, urange4, window_size, pos};
    }
};
//![adaptor_def]

} // namespace seqan3::detail

namespace seqan3::views
{
/*!\brief Computes syncmers for a range of comparable values. A syncmer is a window with size k that has
 * its smallest subwindow of size s, (s < k) at one of the predetermined positions.
 * \tparam urng_t The type of the first range being processed. See below for requirements. [template
 *                 parameter is omitted in pipe notation]
 * \param[in] urange1     The first input range to process. Must model std::ranges::viewable_range and
 *                        std::ranges::forward_range.
 * \param[in] urange2     The second input range to process. Must model std::ranges::viewable_range and
 *                        std::ranges::forward_range.
 * \param[in] window_size The number of elements in one window (should be window size - subwindow size + 1).
 * \param[in] pos	  The position that determines if an element is a syncmer.
 * \returns A range of std::totally_ordered where each value is ... See below for the
 *          properties of the returned range.
 * \ingroup search_views
 *
 * A Syncmer as defined by [Edgar R.](https://peerj.com/articles/10805.pdf) is a kmer that has its smallest smer
 * (s < k) at at one of the predetermined positions. For example for the following sequence
 * `ACGGCGACGTT` and 5 as `window size`, 2 as `subwindow size`, and the positions [0,3] the closed-syncmer values are
 * `ACGGC,CGGCG,GCGAC,ACGTT`.
 *
 *
 *
 * ### View properties
 *
 * | Concepts and traits              | `urng_t` (underlying range type)   | `rrng_t` (returned range type)   |
 * |----------------------------------|:----------------------------------:|:--------------------------------:|
 * | std::ranges::input_range         | *required*                         | *preserved*                      |
 * | std::ranges::forward_range       | *required*                         | *preserved*                      |
 * | std::ranges::bidirectional_range |                                    | *lost*                           |
 * | std::ranges::random_access_range |                                    | *lost*                           |
 * | std::ranges::contiguous_range    |                                    | *lost*                           |
 * |                                  |                                    |                                  |
 * | std::ranges::viewable_range      | *required*                         | *guaranteed*                     |
 * | std::ranges::view                |                                    | *guaranteed*                     |
 * | std::ranges::sized_range         |                                    | *lost*                           |
 * | std::ranges::common_range        |                                    | *lost*                           |
 * | std::ranges::output_range        |                                    | *lost*                           |
 * | seqan3::const_iterable_range     |                                    | *preserved*                      |
 * |                                  |                                    |                                  |
 * | std::ranges::range_reference_t   | std::totally_ordered               | std::totally_ordered             |
 *
 * See the views views submodule documentation for detailed descriptions of the view properties.
 */
inline constexpr auto syncmer = detail::syncmer_fn{};

} // namespace seqan3::views

using seqan3::operator""_dna4;

seqan3::dna4 transform_to_dna(uint64_t letter)
{
    switch (letter)
    {
       case 0:
          return 'A'_dna4;
          break;
       case 1:
          return 'C'_dna4;
          break;
       case 2:
          return 'G'_dna4;
          break;
       case 3:
          return 'T'_dna4;
          break;
      default:
         return 'A'_dna4;

    }
}

bool syncmer_filter(uint64_t seq, uint64_t smer, uint64_t kmer, std::vector<int> const positions, uint64_t const seed = 0x8F3F73B5CF1C9ADE)
{
    uint64_t mod{};
    seq = seq ^ seed;
    std::deque<seqan3::dna4> text{};

    while(seq > 4)
    {
        mod = seq % 4;
        seq = seq/4;
        text.push_front(transform_to_dna(mod));
    }
    mod = seq % 4;
    text.push_front(transform_to_dna(mod));

    while(text.size() < kmer)
    {
        text.push_front(transform_to_dna(0));
    }

    auto smers = text | seqan3::views::kmer_hash(seqan3::shape(seqan3::ungapped(smer)));
    size_t min_pos{};
    uint64_t min = std::numeric_limits<uint64_t>::max();
    int i{0};
    for (auto && hash : smers)
    {
        if (hash < min)
        {
            min = hash;
            min_pos = i;
        }
        ++i;
    }

    return (std::find(positions.begin(), positions.end(), min_pos) != positions.end());
}
